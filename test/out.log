合计总页数：24
https://code.sohuno.com/?page=2
 --- modulename: my_utils, funcname: <module>
<string>(1)
 --- modulename: my_utils, funcname: get_html
my_utils.py(22):      session = requests.Session()
 --- modulename: sessions, funcname: __init__
sessions.py(394):          self.headers = default_headers()
 --- modulename: utils, funcname: default_headers
utils.py(904):      return CaseInsensitiveDict(
utils.py(906):              "User-Agent": default_user_agent(),
 --- modulename: utils, funcname: default_user_agent
utils.py(897):      return f"{name}/{__version__}"
utils.py(907):              "Accept-Encoding": DEFAULT_ACCEPT_ENCODING,
utils.py(908):              "Accept": "*/*",
utils.py(909):              "Connection": "keep-alive",
utils.py(905):          {
utils.py(904):      return CaseInsensitiveDict(
 --- modulename: structures, funcname: __init__
structures.py(41):          self._store = OrderedDict()
structures.py(42):          if data is None:
structures.py(44):          self.update(data, **kwargs)
 --- modulename: _collections_abc, funcname: update
<frozen _collections_abc>(985)
 --- modulename: abc, funcname: __instancecheck__
<frozen abc>(119)
<frozen _collections_abc>(986)
<frozen _collections_abc>(987)
 --- modulename: structures, funcname: __setitem__
structures.py(49):          self._store[key.lower()] = (key, value)
<frozen _collections_abc>(986)
<frozen _collections_abc>(987)
 --- modulename: structures, funcname: __setitem__
structures.py(49):          self._store[key.lower()] = (key, value)
<frozen _collections_abc>(986)
<frozen _collections_abc>(987)
 --- modulename: structures, funcname: __setitem__
structures.py(49):          self._store[key.lower()] = (key, value)
<frozen _collections_abc>(986)
<frozen _collections_abc>(987)
 --- modulename: structures, funcname: __setitem__
structures.py(49):          self._store[key.lower()] = (key, value)
<frozen _collections_abc>(986)
<frozen _collections_abc>(994)
sessions.py(398):          self.auth = None
sessions.py(403):          self.proxies = {}
sessions.py(406):          self.hooks = default_hooks()
 --- modulename: hooks, funcname: default_hooks
hooks.py(16):      return {event: [] for event in HOOKS}
hooks.py(16):      return {event: [] for event in HOOKS}
sessions.py(411):          self.params = {}
sessions.py(414):          self.stream = False
sessions.py(424):          self.verify = True
sessions.py(428):          self.cert = None
sessions.py(434):          self.max_redirects = DEFAULT_REDIRECT_LIMIT
sessions.py(438):          self.trust_env = True
sessions.py(444):          self.cookies = cookiejar_from_dict({})
 --- modulename: cookies, funcname: cookiejar_from_dict
cookies.py(530):      if cookiejar is None:
cookies.py(531):          cookiejar = RequestsCookieJar()
 --- modulename: cookiejar, funcname: __init__
cookiejar.py(1262):          if policy is None:
cookiejar.py(1263):              policy = DefaultCookiePolicy()
 --- modulename: cookiejar, funcname: __init__
cookiejar.py(898):          self.netscape = netscape
cookiejar.py(899):          self.rfc2965 = rfc2965
cookiejar.py(900):          self.rfc2109_as_netscape = rfc2109_as_netscape
cookiejar.py(901):          self.hide_cookie2 = hide_cookie2
cookiejar.py(902):          self.strict_domain = strict_domain
cookiejar.py(903):          self.strict_rfc2965_unverifiable = strict_rfc2965_unverifiable
cookiejar.py(904):          self.strict_ns_unverifiable = strict_ns_unverifiable
cookiejar.py(905):          self.strict_ns_domain = strict_ns_domain
cookiejar.py(906):          self.strict_ns_set_initial_dollar = strict_ns_set_initial_dollar
cookiejar.py(907):          self.strict_ns_set_path = strict_ns_set_path
cookiejar.py(908):          self.secure_protocols = secure_protocols
cookiejar.py(910):          if blocked_domains is not None:
cookiejar.py(913):              self._blocked_domains = ()
cookiejar.py(915):          if allowed_domains is not None:
cookiejar.py(917):          self._allowed_domains = allowed_domains
cookiejar.py(1264):          self._policy = policy
cookiejar.py(1266):          self._cookies_lock = _threading.RLock()
 --- modulename: threading, funcname: RLock
threading.py(131):      if args or kwargs:
threading.py(137):      if _CRLock is None:
threading.py(139):      return _CRLock(*args, **kwargs)
cookiejar.py(1267):          self._cookies = {}
cookies.py(533):      if cookie_dict is not None:
cookies.py(534):          names_from_jar = [cookie.name for cookie in cookiejar]
 --- modulename: cookiejar, funcname: __iter__
cookiejar.py(1754):          return deepvalues(self._cookies)
 --- modulename: cookiejar, funcname: deepvalues
cookiejar.py(1229):      for obj in list(mapping.values()):
cookies.py(535):          for name in cookie_dict:
cookies.py(539):      return cookiejar
sessions.py(447):          self.adapters = OrderedDict()
sessions.py(448):          self.mount("https://", HTTPAdapter())
 --- modulename: adapters, funcname: __init__
adapters.py(209):          if max_retries == DEFAULT_RETRIES:
adapters.py(210):              self.max_retries = Retry(0, read=False)
 --- modulename: retry, funcname: __init__
retry.py(223):          self.total = total
retry.py(224):          self.connect = connect
retry.py(225):          self.read = read
retry.py(226):          self.status = status
retry.py(227):          self.other = other
retry.py(229):          if redirect is False or total is False:
retry.py(233):          self.redirect = redirect
retry.py(234):          self.status_forcelist = status_forcelist or set()
retry.py(235):          self.allowed_methods = allowed_methods
retry.py(236):          self.backoff_factor = backoff_factor
retry.py(237):          self.backoff_max = backoff_max
retry.py(238):          self.raise_on_redirect = raise_on_redirect
retry.py(239):          self.raise_on_status = raise_on_status
retry.py(240):          self.history = history or ()
retry.py(241):          self.respect_retry_after_header = respect_retry_after_header
retry.py(242):          self.remove_headers_on_redirect = frozenset(
retry.py(243):              h.lower() for h in remove_headers_on_redirect
retry.py(242):          self.remove_headers_on_redirect = frozenset(
 --- modulename: retry, funcname: <genexpr>
retry.py(242):          self.remove_headers_on_redirect = frozenset(
retry.py(243):              h.lower() for h in remove_headers_on_redirect
 --- modulename: retry, funcname: <genexpr>
retry.py(243):              h.lower() for h in remove_headers_on_redirect
 --- modulename: retry, funcname: <genexpr>
retry.py(243):              h.lower() for h in remove_headers_on_redirect
 --- modulename: retry, funcname: <genexpr>
retry.py(243):              h.lower() for h in remove_headers_on_redirect
retry.py(245):          self.backoff_jitter = backoff_jitter
adapters.py(213):          self.config = {}
adapters.py(214):          self.proxy_manager = {}
adapters.py(216):          super().__init__()
 --- modulename: adapters, funcname: __init__
adapters.py(141):          super().__init__()
adapters.py(218):          self._pool_connections = pool_connections
adapters.py(219):          self._pool_maxsize = pool_maxsize
adapters.py(220):          self._pool_block = pool_block
adapters.py(222):          self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)
 --- modulename: adapters, funcname: init_poolmanager
adapters.py(255):          self._pool_connections = connections
adapters.py(256):          self._pool_maxsize = maxsize
adapters.py(257):          self._pool_block = block
adapters.py(259):          self.poolmanager = PoolManager(
adapters.py(260):              num_pools=connections,
adapters.py(261):              maxsize=maxsize,
adapters.py(262):              block=block,
adapters.py(259):          self.poolmanager = PoolManager(
adapters.py(263):              **pool_kwargs,
adapters.py(259):          self.poolmanager = PoolManager(
 --- modulename: poolmanager, funcname: __init__
poolmanager.py(205):          super().__init__(headers)
 --- modulename: _request_methods, funcname: __init__
_request_methods.py(52):          self.headers = headers or {}
poolmanager.py(206):          self.connection_pool_kw = connection_pool_kw
poolmanager.py(208):          self.pools: RecentlyUsedContainer[PoolKey, HTTPConnectionPool]
poolmanager.py(209):          self.pools = RecentlyUsedContainer(num_pools)
 --- modulename: _collections, funcname: __init__
_collections.py(89):          super().__init__()
_collections.py(90):          self._maxsize = maxsize
_collections.py(91):          self.dispose_func = dispose_func
_collections.py(92):          self._container = OrderedDict()
_collections.py(93):          self.lock = RLock()
 --- modulename: threading, funcname: RLock
threading.py(131):      if args or kwargs:
threading.py(137):      if _CRLock is None:
threading.py(139):      return _CRLock(*args, **kwargs)
poolmanager.py(213):          self.pool_classes_by_scheme = pool_classes_by_scheme
poolmanager.py(214):          self.key_fn_by_scheme = key_fn_by_scheme.copy()
 --- modulename: sessions, funcname: mount
sessions.py(804):          self.adapters[prefix] = adapter
sessions.py(805):          keys_to_move = [k for k in self.adapters if len(k) < len(prefix)]
sessions.py(805):          keys_to_move = [k for k in self.adapters if len(k) < len(prefix)]
sessions.py(807):          for key in keys_to_move:
sessions.py(449):          self.mount("http://", HTTPAdapter())
 --- modulename: adapters, funcname: __init__
adapters.py(209):          if max_retries == DEFAULT_RETRIES:
adapters.py(210):              self.max_retries = Retry(0, read=False)
 --- modulename: retry, funcname: __init__
retry.py(223):          self.total = total
retry.py(224):          self.connect = connect
retry.py(225):          self.read = read
retry.py(226):          self.status = status
retry.py(227):          self.other = other
retry.py(229):          if redirect is False or total is False:
retry.py(233):          self.redirect = redirect
retry.py(234):          self.status_forcelist = status_forcelist or set()
retry.py(235):          self.allowed_methods = allowed_methods
retry.py(236):          self.backoff_factor = backoff_factor
retry.py(237):          self.backoff_max = backoff_max
retry.py(238):          self.raise_on_redirect = raise_on_redirect
retry.py(239):          self.raise_on_status = raise_on_status
retry.py(240):          self.history = history or ()
retry.py(241):          self.respect_retry_after_header = respect_retry_after_header
retry.py(242):          self.remove_headers_on_redirect = frozenset(
retry.py(243):              h.lower() for h in remove_headers_on_redirect
retry.py(242):          self.remove_headers_on_redirect = frozenset(
 --- modulename: retry, funcname: <genexpr>
retry.py(242):          self.remove_headers_on_redirect = frozenset(
retry.py(243):              h.lower() for h in remove_headers_on_redirect
 --- modulename: retry, funcname: <genexpr>
retry.py(243):              h.lower() for h in remove_headers_on_redirect
 --- modulename: retry, funcname: <genexpr>
retry.py(243):              h.lower() for h in remove_headers_on_redirect
 --- modulename: retry, funcname: <genexpr>
retry.py(243):              h.lower() for h in remove_headers_on_redirect
retry.py(245):          self.backoff_jitter = backoff_jitter
adapters.py(213):          self.config = {}
adapters.py(214):          self.proxy_manager = {}
adapters.py(216):          super().__init__()
 --- modulename: adapters, funcname: __init__
adapters.py(141):          super().__init__()
adapters.py(218):          self._pool_connections = pool_connections
adapters.py(219):          self._pool_maxsize = pool_maxsize
adapters.py(220):          self._pool_block = pool_block
adapters.py(222):          self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)
 --- modulename: adapters, funcname: init_poolmanager
adapters.py(255):          self._pool_connections = connections
adapters.py(256):          self._pool_maxsize = maxsize
adapters.py(257):          self._pool_block = block
adapters.py(259):          self.poolmanager = PoolManager(
adapters.py(260):              num_pools=connections,
adapters.py(261):              maxsize=maxsize,
adapters.py(262):              block=block,
adapters.py(259):          self.poolmanager = PoolManager(
adapters.py(263):              **pool_kwargs,
adapters.py(259):          self.poolmanager = PoolManager(
 --- modulename: poolmanager, funcname: __init__
poolmanager.py(205):          super().__init__(headers)
 --- modulename: _request_methods, funcname: __init__
_request_methods.py(52):          self.headers = headers or {}
poolmanager.py(206):          self.connection_pool_kw = connection_pool_kw
poolmanager.py(208):          self.pools: RecentlyUsedContainer[PoolKey, HTTPConnectionPool]
poolmanager.py(209):          self.pools = RecentlyUsedContainer(num_pools)
 --- modulename: _collections, funcname: __init__
_collections.py(89):          super().__init__()
_collections.py(90):          self._maxsize = maxsize
_collections.py(91):          self.dispose_func = dispose_func
_collections.py(92):          self._container = OrderedDict()
_collections.py(93):          self.lock = RLock()
 --- modulename: threading, funcname: RLock
threading.py(131):      if args or kwargs:
threading.py(137):      if _CRLock is None:
threading.py(139):      return _CRLock(*args, **kwargs)
poolmanager.py(213):          self.pool_classes_by_scheme = pool_classes_by_scheme
poolmanager.py(214):          self.key_fn_by_scheme = key_fn_by_scheme.copy()
 --- modulename: sessions, funcname: mount
sessions.py(804):          self.adapters[prefix] = adapter
sessions.py(805):          keys_to_move = [k for k in self.adapters if len(k) < len(prefix)]
sessions.py(805):          keys_to_move = [k for k in self.adapters if len(k) < len(prefix)]
sessions.py(805):          keys_to_move = [k for k in self.adapters if len(k) < len(prefix)]
sessions.py(807):          for key in keys_to_move:
my_utils.py(26):      for cookie_name, cookie_value in cookies_dict.items():
my_utils.py(27):          session.cookies.set(cookie_name, cookie_value)
 --- modulename: cookies, funcname: set
cookies.py(212):          if value is None:
cookies.py(218):          if isinstance(value, Morsel):
cookies.py(221):              c = create_cookie(name, value, **kwargs)
 --- modulename: cookies, funcname: create_cookie
cookies.py(462):          "version": 0,
cookies.py(463):          "name": name,
cookies.py(464):          "value": value,
cookies.py(465):          "port": None,
cookies.py(466):          "domain": "",
cookies.py(467):          "path": "/",
cookies.py(468):          "secure": False,
cookies.py(469):          "expires": None,
cookies.py(470):          "discard": True,
cookies.py(471):          "comment": None,
cookies.py(472):          "comment_url": None,
cookies.py(473):          "rest": {"HttpOnly": None},
cookies.py(474):          "rfc2109": False,
cookies.py(461):      result = {
cookies.py(477):      badargs = set(kwargs) - set(result)
cookies.py(478):      if badargs:
cookies.py(483):      result.update(kwargs)
cookies.py(484):      result["port_specified"] = bool(result["port"])
cookies.py(485):      result["domain_specified"] = bool(result["domain"])
cookies.py(486):      result["domain_initial_dot"] = result["domain"].startswith(".")
cookies.py(487):      result["path_specified"] = bool(result["path"])
cookies.py(489):      return cookielib.Cookie(**result)
 --- modulename: cookiejar, funcname: __init__
cookiejar.py(774):          if version is not None: version = int(version)
cookiejar.py(775):          if expires is not None: expires = int(float(expires))
cookiejar.py(776):          if port is None and port_specified is True:
cookiejar.py(779):          self.version = version
cookiejar.py(780):          self.name = name
cookiejar.py(781):          self.value = value
cookiejar.py(782):          self.port = port
cookiejar.py(783):          self.port_specified = port_specified
cookiejar.py(785):          self.domain = domain.lower()
cookiejar.py(786):          self.domain_specified = domain_specified
cookiejar.py(791):          self.domain_initial_dot = domain_initial_dot
cookiejar.py(792):          self.path = path
cookiejar.py(793):          self.path_specified = path_specified
cookiejar.py(794):          self.secure = secure
cookiejar.py(795):          self.expires = expires
cookiejar.py(796):          self.discard = discard
cookiejar.py(797):          self.comment = comment
cookiejar.py(798):          self.comment_url = comment_url
cookiejar.py(799):          self.rfc2109 = rfc2109
cookiejar.py(801):          self._rest = copy.copy(rest)
 --- modulename: copy, funcname: copy
copy.py(68):      cls = type(x)
copy.py(70):      copier = _copy_dispatch.get(cls)
copy.py(71):      if copier:
copy.py(72):          return copier(x)
cookies.py(222):          self.set_cookie(c)
 --- modulename: cookies, funcname: set_cookie
cookies.py(351):              hasattr(cookie.value, "startswith")
cookies.py(352):              and cookie.value.startswith('"')
cookies.py(356):          return super().set_cookie(cookie, *args, **kwargs)
 --- modulename: cookiejar, funcname: set_cookie
cookiejar.py(1669):          c = self._cookies
cookiejar.py(1670):          self._cookies_lock.acquire()
cookiejar.py(1671):          try:
cookiejar.py(1672):              if cookie.domain not in c: c[cookie.domain] = {}
cookiejar.py(1673):              c2 = c[cookie.domain]
cookiejar.py(1674):              if cookie.path not in c2: c2[cookie.path] = {}
cookiejar.py(1675):              c3 = c2[cookie.path]
cookiejar.py(1676):              c3[cookie.name] = cookie
cookiejar.py(1678):              self._cookies_lock.release()
cookies.py(223):          return c
my_utils.py(26):      for cookie_name, cookie_value in cookies_dict.items():
my_utils.py(27):          session.cookies.set(cookie_name, cookie_value)
 --- modulename: cookies, funcname: set
cookies.py(212):          if value is None:
cookies.py(218):          if isinstance(value, Morsel):
cookies.py(221):              c = create_cookie(name, value, **kwargs)
 --- modulename: cookies, funcname: create_cookie
cookies.py(462):          "version": 0,
cookies.py(463):          "name": name,
cookies.py(464):          "value": value,
cookies.py(465):          "port": None,
cookies.py(466):          "domain": "",
cookies.py(467):          "path": "/",
cookies.py(468):          "secure": False,
cookies.py(469):          "expires": None,
cookies.py(470):          "discard": True,
cookies.py(471):          "comment": None,
cookies.py(472):          "comment_url": None,
cookies.py(473):          "rest": {"HttpOnly": None},
cookies.py(474):          "rfc2109": False,
cookies.py(461):      result = {
cookies.py(477):      badargs = set(kwargs) - set(result)
cookies.py(478):      if badargs:
cookies.py(483):      result.update(kwargs)
cookies.py(484):      result["port_specified"] = bool(result["port"])
cookies.py(485):      result["domain_specified"] = bool(result["domain"])
cookies.py(486):      result["domain_initial_dot"] = result["domain"].startswith(".")
cookies.py(487):      result["path_specified"] = bool(result["path"])
cookies.py(489):      return cookielib.Cookie(**result)
 --- modulename: cookiejar, funcname: __init__
cookiejar.py(774):          if version is not None: version = int(version)
cookiejar.py(775):          if expires is not None: expires = int(float(expires))
cookiejar.py(776):          if port is None and port_specified is True:
cookiejar.py(779):          self.version = version
cookiejar.py(780):          self.name = name
cookiejar.py(781):          self.value = value
cookiejar.py(782):          self.port = port
cookiejar.py(783):          self.port_specified = port_specified
cookiejar.py(785):          self.domain = domain.lower()
cookiejar.py(786):          self.domain_specified = domain_specified
cookiejar.py(791):          self.domain_initial_dot = domain_initial_dot
cookiejar.py(792):          self.path = path
cookiejar.py(793):          self.path_specified = path_specified
cookiejar.py(794):          self.secure = secure
cookiejar.py(795):          self.expires = expires
cookiejar.py(796):          self.discard = discard
cookiejar.py(797):          self.comment = comment
cookiejar.py(798):          self.comment_url = comment_url
cookiejar.py(799):          self.rfc2109 = rfc2109
cookiejar.py(801):          self._rest = copy.copy(rest)
 --- modulename: copy, funcname: copy
copy.py(68):      cls = type(x)
copy.py(70):      copier = _copy_dispatch.get(cls)
copy.py(71):      if copier:
copy.py(72):          return copier(x)
cookies.py(222):          self.set_cookie(c)
 --- modulename: cookies, funcname: set_cookie
cookies.py(351):              hasattr(cookie.value, "startswith")
cookies.py(352):              and cookie.value.startswith('"')
cookies.py(356):          return super().set_cookie(cookie, *args, **kwargs)
 --- modulename: cookiejar, funcname: set_cookie
cookiejar.py(1669):          c = self._cookies
cookiejar.py(1670):          self._cookies_lock.acquire()
cookiejar.py(1671):          try:
cookiejar.py(1672):              if cookie.domain not in c: c[cookie.domain] = {}
cookiejar.py(1673):              c2 = c[cookie.domain]
cookiejar.py(1674):              if cookie.path not in c2: c2[cookie.path] = {}
cookiejar.py(1675):              c3 = c2[cookie.path]
cookiejar.py(1676):              c3[cookie.name] = cookie
cookiejar.py(1678):              self._cookies_lock.release()
cookies.py(223):          return c
my_utils.py(26):      for cookie_name, cookie_value in cookies_dict.items():
my_utils.py(27):          session.cookies.set(cookie_name, cookie_value)
 --- modulename: cookies, funcname: set
cookies.py(212):          if value is None:
cookies.py(218):          if isinstance(value, Morsel):
cookies.py(221):              c = create_cookie(name, value, **kwargs)
 --- modulename: cookies, funcname: create_cookie
cookies.py(462):          "version": 0,
cookies.py(463):          "name": name,
cookies.py(464):          "value": value,
cookies.py(465):          "port": None,
cookies.py(466):          "domain": "",
cookies.py(467):          "path": "/",
cookies.py(468):          "secure": False,
cookies.py(469):          "expires": None,
cookies.py(470):          "discard": True,
cookies.py(471):          "comment": None,
cookies.py(472):          "comment_url": None,
cookies.py(473):          "rest": {"HttpOnly": None},
cookies.py(474):          "rfc2109": False,
cookies.py(461):      result = {
cookies.py(477):      badargs = set(kwargs) - set(result)
cookies.py(478):      if badargs:
cookies.py(483):      result.update(kwargs)
cookies.py(484):      result["port_specified"] = bool(result["port"])
cookies.py(485):      result["domain_specified"] = bool(result["domain"])
cookies.py(486):      result["domain_initial_dot"] = result["domain"].startswith(".")
cookies.py(487):      result["path_specified"] = bool(result["path"])
cookies.py(489):      return cookielib.Cookie(**result)
 --- modulename: cookiejar, funcname: __init__
cookiejar.py(774):          if version is not None: version = int(version)
cookiejar.py(775):          if expires is not None: expires = int(float(expires))
cookiejar.py(776):          if port is None and port_specified is True:
cookiejar.py(779):          self.version = version
cookiejar.py(780):          self.name = name
cookiejar.py(781):          self.value = value
cookiejar.py(782):          self.port = port
cookiejar.py(783):          self.port_specified = port_specified
cookiejar.py(785):          self.domain = domain.lower()
cookiejar.py(786):          self.domain_specified = domain_specified
cookiejar.py(791):          self.domain_initial_dot = domain_initial_dot
cookiejar.py(792):          self.path = path
cookiejar.py(793):          self.path_specified = path_specified
cookiejar.py(794):          self.secure = secure
cookiejar.py(795):          self.expires = expires
cookiejar.py(796):          self.discard = discard
cookiejar.py(797):          self.comment = comment
cookiejar.py(798):          self.comment_url = comment_url
cookiejar.py(799):          self.rfc2109 = rfc2109
cookiejar.py(801):          self._rest = copy.copy(rest)
 --- modulename: copy, funcname: copy
copy.py(68):      cls = type(x)
copy.py(70):      copier = _copy_dispatch.get(cls)
copy.py(71):      if copier:
copy.py(72):          return copier(x)
cookies.py(222):          self.set_cookie(c)
 --- modulename: cookies, funcname: set_cookie
cookies.py(351):              hasattr(cookie.value, "startswith")
cookies.py(352):              and cookie.value.startswith('"')
cookies.py(356):          return super().set_cookie(cookie, *args, **kwargs)
 --- modulename: cookiejar, funcname: set_cookie
cookiejar.py(1669):          c = self._cookies
cookiejar.py(1670):          self._cookies_lock.acquire()
cookiejar.py(1671):          try:
cookiejar.py(1672):              if cookie.domain not in c: c[cookie.domain] = {}
cookiejar.py(1673):              c2 = c[cookie.domain]
cookiejar.py(1674):              if cookie.path not in c2: c2[cookie.path] = {}
cookiejar.py(1675):              c3 = c2[cookie.path]
cookiejar.py(1676):              c3[cookie.name] = cookie
cookiejar.py(1678):              self._cookies_lock.release()
cookies.py(223):          return c
my_utils.py(26):      for cookie_name, cookie_value in cookies_dict.items():
my_utils.py(29):      try:
my_utils.py(30):          response = session.get(url)
 --- modulename: sessions, funcname: get
sessions.py(601):          kwargs.setdefault("allow_redirects", True)
sessions.py(602):          return self.request("GET", url, **kwargs)
 --- modulename: sessions, funcname: request
sessions.py(563):          req = Request(
sessions.py(564):              method=method.upper(),
sessions.py(565):              url=url,
sessions.py(566):              headers=headers,
sessions.py(567):              files=files,
sessions.py(568):              data=data or {},
sessions.py(569):              json=json,
sessions.py(570):              params=params or {},
sessions.py(571):              auth=auth,
sessions.py(572):              cookies=cookies,
sessions.py(573):              hooks=hooks,
sessions.py(563):          req = Request(
 --- modulename: models, funcname: __init__
models.py(272):          data = [] if data is None else data
models.py(273):          files = [] if files is None else files
models.py(274):          headers = {} if headers is None else headers
models.py(275):          params = {} if params is None else params
models.py(276):          hooks = {} if hooks is None else hooks
models.py(278):          self.hooks = default_hooks()
 --- modulename: hooks, funcname: default_hooks
hooks.py(16):      return {event: [] for event in HOOKS}
hooks.py(16):      return {event: [] for event in HOOKS}
models.py(279):          for k, v in list(hooks.items()):
models.py(282):          self.method = method
models.py(283):          self.url = url
models.py(284):          self.headers = headers
models.py(285):          self.files = files
models.py(286):          self.data = data
models.py(287):          self.json = json
models.py(288):          self.params = params
models.py(289):          self.auth = auth
models.py(290):          self.cookies = cookies
sessions.py(575):          prep = self.prepare_request(req)
 --- modulename: sessions, funcname: prepare_request
sessions.py(467):          cookies = request.cookies or {}
sessions.py(470):          if not isinstance(cookies, cookielib.CookieJar):
sessions.py(471):              cookies = cookiejar_from_dict(cookies)
 --- modulename: cookies, funcname: cookiejar_from_dict
cookies.py(530):      if cookiejar is None:
cookies.py(531):          cookiejar = RequestsCookieJar()
 --- modulename: cookiejar, funcname: __init__
cookiejar.py(1262):          if policy is None:
cookiejar.py(1263):              policy = DefaultCookiePolicy()
 --- modulename: cookiejar, funcname: __init__
cookiejar.py(898):          self.netscape = netscape
cookiejar.py(899):          self.rfc2965 = rfc2965
cookiejar.py(900):          self.rfc2109_as_netscape = rfc2109_as_netscape
cookiejar.py(901):          self.hide_cookie2 = hide_cookie2
cookiejar.py(902):          self.strict_domain = strict_domain
cookiejar.py(903):          self.strict_rfc2965_unverifiable = strict_rfc2965_unverifiable
cookiejar.py(904):          self.strict_ns_unverifiable = strict_ns_unverifiable
cookiejar.py(905):          self.strict_ns_domain = strict_ns_domain
cookiejar.py(906):          self.strict_ns_set_initial_dollar = strict_ns_set_initial_dollar
cookiejar.py(907):          self.strict_ns_set_path = strict_ns_set_path
cookiejar.py(908):          self.secure_protocols = secure_protocols
cookiejar.py(910):          if blocked_domains is not None:
cookiejar.py(913):              self._blocked_domains = ()
cookiejar.py(915):          if allowed_domains is not None:
cookiejar.py(917):          self._allowed_domains = allowed_domains
cookiejar.py(1264):          self._policy = policy
cookiejar.py(1266):          self._cookies_lock = _threading.RLock()
 --- modulename: threading, funcname: RLock
threading.py(131):      if args or kwargs:
threading.py(137):      if _CRLock is None:
threading.py(139):      return _CRLock(*args, **kwargs)
cookiejar.py(1267):          self._cookies = {}
cookies.py(533):      if cookie_dict is not None:
cookies.py(534):          names_from_jar = [cookie.name for cookie in cookiejar]
 --- modulename: cookiejar, funcname: __iter__
cookiejar.py(1754):          return deepvalues(self._cookies)
 --- modulename: cookiejar, funcname: deepvalues
cookiejar.py(1229):      for obj in list(mapping.values()):
cookies.py(535):          for name in cookie_dict:
cookies.py(539):      return cookiejar
sessions.py(474):          merged_cookies = merge_cookies(
sessions.py(475):              merge_cookies(RequestsCookieJar(), self.cookies), cookies
 --- modulename: cookiejar, funcname: __init__
cookiejar.py(1262):          if policy is None:
cookiejar.py(1263):              policy = DefaultCookiePolicy()
 --- modulename: cookiejar, funcname: __init__
cookiejar.py(898):          self.netscape = netscape
cookiejar.py(899):          self.rfc2965 = rfc2965
cookiejar.py(900):          self.rfc2109_as_netscape = rfc2109_as_netscape
cookiejar.py(901):          self.hide_cookie2 = hide_cookie2
cookiejar.py(902):          self.strict_domain = strict_domain
cookiejar.py(903):          self.strict_rfc2965_unverifiable = strict_rfc2965_unverifiable
cookiejar.py(904):          self.strict_ns_unverifiable = strict_ns_unverifiable
cookiejar.py(905):          self.strict_ns_domain = strict_ns_domain
cookiejar.py(906):          self.strict_ns_set_initial_dollar = strict_ns_set_initial_dollar
cookiejar.py(907):          self.strict_ns_set_path = strict_ns_set_path
cookiejar.py(908):          self.secure_protocols = secure_protocols
cookiejar.py(910):          if blocked_domains is not None:
cookiejar.py(913):              self._blocked_domains = ()
cookiejar.py(915):          if allowed_domains is not None:
cookiejar.py(917):          self._allowed_domains = allowed_domains
cookiejar.py(1264):          self._policy = policy
cookiejar.py(1266):          self._cookies_lock = _threading.RLock()
 --- modulename: threading, funcname: RLock
threading.py(131):      if args or kwargs:
threading.py(137):      if _CRLock is None:
threading.py(139):      return _CRLock(*args, **kwargs)
cookiejar.py(1267):          self._cookies = {}
 --- modulename: cookies, funcname: merge_cookies
cookies.py(549):      if not isinstance(cookiejar, cookielib.CookieJar):
cookies.py(552):      if isinstance(cookies, dict):
cookies.py(554):      elif isinstance(cookies, cookielib.CookieJar):
cookies.py(555):          try:
cookies.py(556):              cookiejar.update(cookies)
 --- modulename: cookies, funcname: update
cookies.py(360):          if isinstance(other, cookielib.CookieJar):
cookies.py(361):              for cookie in other:
 --- modulename: cookiejar, funcname: __iter__
cookiejar.py(1754):          return deepvalues(self._cookies)
 --- modulename: cookiejar, funcname: deepvalues
cookiejar.py(1229):      for obj in list(mapping.values()):
cookiejar.py(1230):          mapping = False
cookiejar.py(1231):          try:
cookiejar.py(1232):              obj.items
cookiejar.py(1236):              mapping = True
cookiejar.py(1237):              yield from deepvalues(obj)
 --- modulename: cookiejar, funcname: deepvalues
cookiejar.py(1229):      for obj in list(mapping.values()):
cookiejar.py(1230):          mapping = False
cookiejar.py(1231):          try:
cookiejar.py(1232):              obj.items
cookiejar.py(1236):              mapping = True
cookiejar.py(1237):              yield from deepvalues(obj)
 --- modulename: cookiejar, funcname: deepvalues
cookiejar.py(1229):      for obj in list(mapping.values()):
cookiejar.py(1230):          mapping = False
cookiejar.py(1231):          try:
cookiejar.py(1232):              obj.items
cookiejar.py(1233):          except AttributeError:
cookiejar.py(1234):              pass
cookiejar.py(1238):          if not mapping:
cookiejar.py(1239):              yield obj
cookies.py(362):                  self.set_cookie(copy.copy(cookie))
 --- modulename: copy, funcname: copy
copy.py(68):      cls = type(x)
copy.py(70):      copier = _copy_dispatch.get(cls)
copy.py(71):      if copier:
copy.py(74):      if issubclass(cls, type):
copy.py(78):      copier = getattr(cls, "__copy__", None)
copy.py(79):      if copier is not None:
copy.py(82):      reductor = dispatch_table.get(cls)
copy.py(83):      if reductor is not None:
copy.py(86):          reductor = getattr(x, "__reduce_ex__", None)
copy.py(87):          if reductor is not None:
copy.py(88):              rv = reductor(4)
copy.py(96):      if isinstance(rv, str):
copy.py(98):      return _reconstruct(x, None, *rv)
 --- modulename: copy, funcname: _reconstruct
copy.py(251):      deep = memo is not None
copy.py(252):      if deep and args:
copy.py(254):      y = func(*args)
 --- modulename: copyreg, funcname: __newobj__
copyreg.py(99):      return cls.__new__(cls, *args)
copy.py(255):      if deep:
copy.py(258):      if state is not None:
copy.py(259):          if deep:
copy.py(261):          if hasattr(y, '__setstate__'):
copy.py(264):              if isinstance(state, tuple) and len(state) == 2:
copy.py(267):                  slotstate = None
copy.py(268):              if state is not None:
copy.py(269):                  y.__dict__.update(state)
copy.py(270):              if slotstate is not None:
copy.py(274):      if listiter is not None:
copy.py(282):      if dictiter is not None:
copy.py(291):      return y
 --- modulename: cookies, funcname: set_cookie
cookies.py(351):              hasattr(cookie.value, "startswith")
cookies.py(352):              and cookie.value.startswith('"')
cookies.py(356):          return super().set_cookie(cookie, *args, **kwargs)
 --- modulename: cookiejar, funcname: set_cookie
cookiejar.py(1669):          c = self._cookies
cookiejar.py(1670):          self._cookies_lock.acquire()
cookiejar.py(1671):          try:
cookiejar.py(1672):              if cookie.domain not in c: c[cookie.domain] = {}
cookiejar.py(1673):              c2 = c[cookie.domain]
cookiejar.py(1674):              if cookie.path not in c2: c2[cookie.path] = {}
cookiejar.py(1675):              c3 = c2[cookie.path]
cookiejar.py(1676):              c3[cookie.name] = cookie
cookiejar.py(1678):              self._cookies_lock.release()
cookies.py(361):              for cookie in other:
 --- modulename: cookiejar, funcname: deepvalues
 --- modulename: cookiejar, funcname: deepvalues
 --- modulename: cookiejar, funcname: deepvalues
cookiejar.py(1229):      for obj in list(mapping.values()):
cookiejar.py(1230):          mapping = False
cookiejar.py(1231):          try:
cookiejar.py(1232):              obj.items
cookiejar.py(1233):          except AttributeError:
cookiejar.py(1234):              pass
cookiejar.py(1238):          if not mapping:
cookiejar.py(1239):              yield obj
cookies.py(362):                  self.set_cookie(copy.copy(cookie))
 --- modulename: copy, funcname: copy
copy.py(68):      cls = type(x)
copy.py(70):      copier = _copy_dispatch.get(cls)
copy.py(71):      if copier:
copy.py(74):      if issubclass(cls, type):
copy.py(78):      copier = getattr(cls, "__copy__", None)
copy.py(79):      if copier is not None:
copy.py(82):      reductor = dispatch_table.get(cls)
copy.py(83):      if reductor is not None:
copy.py(86):          reductor = getattr(x, "__reduce_ex__", None)
copy.py(87):          if reductor is not None:
copy.py(88):              rv = reductor(4)
copy.py(96):      if isinstance(rv, str):
copy.py(98):      return _reconstruct(x, None, *rv)
 --- modulename: copy, funcname: _reconstruct
copy.py(251):      deep = memo is not None
copy.py(252):      if deep and args:
copy.py(254):      y = func(*args)
 --- modulename: copyreg, funcname: __newobj__
copyreg.py(99):      return cls.__new__(cls, *args)
copy.py(255):      if deep:
copy.py(258):      if state is not None:
copy.py(259):          if deep:
copy.py(261):          if hasattr(y, '__setstate__'):
copy.py(264):              if isinstance(state, tuple) and len(state) == 2:
copy.py(267):                  slotstate = None
copy.py(268):              if state is not None:
copy.py(269):                  y.__dict__.update(state)
copy.py(270):              if slotstate is not None:
copy.py(274):      if listiter is not None:
copy.py(282):      if dictiter is not None:
copy.py(291):      return y
 --- modulename: cookies, funcname: set_cookie
cookies.py(351):              hasattr(cookie.value, "startswith")
cookies.py(352):              and cookie.value.startswith('"')
cookies.py(356):          return super().set_cookie(cookie, *args, **kwargs)
 --- modulename: cookiejar, funcname: set_cookie
cookiejar.py(1669):          c = self._cookies
cookiejar.py(1670):          self._cookies_lock.acquire()
cookiejar.py(1671):          try:
cookiejar.py(1672):              if cookie.domain not in c: c[cookie.domain] = {}
cookiejar.py(1673):              c2 = c[cookie.domain]
cookiejar.py(1674):              if cookie.path not in c2: c2[cookie.path] = {}
cookiejar.py(1675):              c3 = c2[cookie.path]
cookiejar.py(1676):              c3[cookie.name] = cookie
cookiejar.py(1678):              self._cookies_lock.release()
cookies.py(361):              for cookie in other:
 --- modulename: cookiejar, funcname: deepvalues
 --- modulename: cookiejar, funcname: deepvalues
 --- modulename: cookiejar, funcname: deepvalues
cookiejar.py(1229):      for obj in list(mapping.values()):
cookiejar.py(1230):          mapping = False
cookiejar.py(1231):          try:
cookiejar.py(1232):              obj.items
cookiejar.py(1233):          except AttributeError:
cookiejar.py(1234):              pass
cookiejar.py(1238):          if not mapping:
cookiejar.py(1239):              yield obj
cookies.py(362):                  self.set_cookie(copy.copy(cookie))
 --- modulename: copy, funcname: copy
copy.py(68):      cls = type(x)
copy.py(70):      copier = _copy_dispatch.get(cls)
copy.py(71):      if copier:
copy.py(74):      if issubclass(cls, type):
copy.py(78):      copier = getattr(cls, "__copy__", None)
copy.py(79):      if copier is not None:
copy.py(82):      reductor = dispatch_table.get(cls)
copy.py(83):      if reductor is not None:
copy.py(86):          reductor = getattr(x, "__reduce_ex__", None)
copy.py(87):          if reductor is not None:
copy.py(88):              rv = reductor(4)
copy.py(96):      if isinstance(rv, str):
copy.py(98):      return _reconstruct(x, None, *rv)
 --- modulename: copy, funcname: _reconstruct
copy.py(251):      deep = memo is not None
copy.py(252):      if deep and args:
copy.py(254):      y = func(*args)
 --- modulename: copyreg, funcname: __newobj__
copyreg.py(99):      return cls.__new__(cls, *args)
copy.py(255):      if deep:
copy.py(258):      if state is not None:
copy.py(259):          if deep:
copy.py(261):          if hasattr(y, '__setstate__'):
copy.py(264):              if isinstance(state, tuple) and len(state) == 2:
copy.py(267):                  slotstate = None
copy.py(268):              if state is not None:
copy.py(269):                  y.__dict__.update(state)
copy.py(270):              if slotstate is not None:
copy.py(274):      if listiter is not None:
copy.py(282):      if dictiter is not None:
copy.py(291):      return y
 --- modulename: cookies, funcname: set_cookie
cookies.py(351):              hasattr(cookie.value, "startswith")
cookies.py(352):              and cookie.value.startswith('"')
cookies.py(356):          return super().set_cookie(cookie, *args, **kwargs)
 --- modulename: cookiejar, funcname: set_cookie
cookiejar.py(1669):          c = self._cookies
cookiejar.py(1670):          self._cookies_lock.acquire()
cookiejar.py(1671):          try:
cookiejar.py(1672):              if cookie.domain not in c: c[cookie.domain] = {}
cookiejar.py(1673):              c2 = c[cookie.domain]
cookiejar.py(1674):              if cookie.path not in c2: c2[cookie.path] = {}
cookiejar.py(1675):              c3 = c2[cookie.path]
cookiejar.py(1676):              c3[cookie.name] = cookie
cookiejar.py(1678):              self._cookies_lock.release()
cookies.py(361):              for cookie in other:
 --- modulename: cookiejar, funcname: deepvalues
 --- modulename: cookiejar, funcname: deepvalues
 --- modulename: cookiejar, funcname: deepvalues
cookiejar.py(1229):      for obj in list(mapping.values()):
cookiejar.py(1238):          if not mapping:
cookiejar.py(1229):      for obj in list(mapping.values()):
cookiejar.py(1238):          if not mapping:
cookiejar.py(1229):      for obj in list(mapping.values()):
cookies.py(561):      return cookiejar
sessions.py(474):          merged_cookies = merge_cookies(
 --- modulename: cookies, funcname: merge_cookies
cookies.py(549):      if not isinstance(cookiejar, cookielib.CookieJar):
cookies.py(552):      if isinstance(cookies, dict):
cookies.py(554):      elif isinstance(cookies, cookielib.CookieJar):
cookies.py(555):          try:
cookies.py(556):              cookiejar.update(cookies)
 --- modulename: cookies, funcname: update
cookies.py(360):          if isinstance(other, cookielib.CookieJar):
cookies.py(361):              for cookie in other:
 --- modulename: cookiejar, funcname: __iter__
cookiejar.py(1754):          return deepvalues(self._cookies)
 --- modulename: cookiejar, funcname: deepvalues
cookiejar.py(1229):      for obj in list(mapping.values()):
cookies.py(561):      return cookiejar
sessions.py(479):          auth = request.auth
sessions.py(480):          if self.trust_env and not auth and not self.auth:
sessions.py(481):              auth = get_netrc_auth(request.url)
 --- modulename: utils, funcname: get_netrc_auth
utils.py(207):      netrc_file = os.environ.get("NETRC")
 --- modulename: _collections_abc, funcname: get
<frozen _collections_abc>(810)
<frozen _collections_abc>(811)
 --- modulename: os, funcname: __getitem__
<frozen os>(712)
<frozen os>(713)
 --- modulename: os, funcname: encode
<frozen os>(794)
<frozen os>(796)
<frozen os>(714)
<frozen os>(716)
<frozen _collections_abc>(812)
<frozen _collections_abc>(813)
utils.py(208):      if netrc_file is not None:
utils.py(211):          netrc_locations = (f"~/{f}" for f in NETRC_FILES)
utils.py(213):      try:
utils.py(214):          from netrc import NetrcParseError, netrc
utils.py(216):          netrc_path = None
utils.py(218):          for f in netrc_locations:
 --- modulename: utils, funcname: <genexpr>
utils.py(211):          netrc_locations = (f"~/{f}" for f in NETRC_FILES)
utils.py(219):              try:
utils.py(220):                  loc = os.path.expanduser(f)
 --- modulename: posixpath, funcname: expanduser
<frozen posixpath>(231)
<frozen posixpath>(232)
<frozen posixpath>(235)
<frozen posixpath>(236)
<frozen posixpath>(238)
 --- modulename: posixpath, funcname: _get_sep
<frozen posixpath>(42)
<frozen posixpath>(45)
<frozen posixpath>(239)
<frozen posixpath>(240)
<frozen posixpath>(242)
<frozen posixpath>(243)
 --- modulename: _collections_abc, funcname: __contains__
<frozen _collections_abc>(816)
<frozen _collections_abc>(817)
 --- modulename: os, funcname: __getitem__
<frozen os>(712)
<frozen os>(713)
 --- modulename: os, funcname: encode
<frozen os>(794)
<frozen os>(796)
<frozen os>(717)
 --- modulename: os, funcname: decode
<frozen os>(798)
<frozen _collections_abc>(821)
<frozen posixpath>(256)
 --- modulename: os, funcname: __getitem__
<frozen os>(712)
<frozen os>(713)
 --- modulename: os, funcname: encode
<frozen os>(794)
<frozen os>(796)
<frozen os>(717)
 --- modulename: os, funcname: decode
<frozen os>(798)
<frozen posixpath>(274)
<frozen posixpath>(276)
<frozen posixpath>(278)
<frozen posixpath>(279)
utils.py(227):              if os.path.exists(loc):
 --- modulename: genericpath, funcname: exists
<frozen genericpath>(18)
<frozen genericpath>(19)
<frozen genericpath>(20)
<frozen genericpath>(21)
utils.py(218):          for f in netrc_locations:
 --- modulename: utils, funcname: <genexpr>
utils.py(211):          netrc_locations = (f"~/{f}" for f in NETRC_FILES)
utils.py(219):              try:
utils.py(220):                  loc = os.path.expanduser(f)
 --- modulename: posixpath, funcname: expanduser
<frozen posixpath>(231)
<frozen posixpath>(232)
<frozen posixpath>(235)
<frozen posixpath>(236)
<frozen posixpath>(238)
 --- modulename: posixpath, funcname: _get_sep
<frozen posixpath>(42)
<frozen posixpath>(45)
<frozen posixpath>(239)
<frozen posixpath>(240)
<frozen posixpath>(242)
<frozen posixpath>(243)
 --- modulename: _collections_abc, funcname: __contains__
<frozen _collections_abc>(816)
<frozen _collections_abc>(817)
 --- modulename: os, funcname: __getitem__
<frozen os>(712)
<frozen os>(713)
 --- modulename: os, funcname: encode
<frozen os>(794)
<frozen os>(796)
<frozen os>(717)
 --- modulename: os, funcname: decode
<frozen os>(798)
<frozen _collections_abc>(821)
<frozen posixpath>(256)
 --- modulename: os, funcname: __getitem__
<frozen os>(712)
<frozen os>(713)
 --- modulename: os, funcname: encode
<frozen os>(794)
<frozen os>(796)
<frozen os>(717)
 --- modulename: os, funcname: decode
<frozen os>(798)
<frozen posixpath>(274)
<frozen posixpath>(276)
<frozen posixpath>(278)
<frozen posixpath>(279)
utils.py(227):              if os.path.exists(loc):
 --- modulename: genericpath, funcname: exists
<frozen genericpath>(18)
<frozen genericpath>(19)
<frozen genericpath>(20)
<frozen genericpath>(21)
utils.py(218):          for f in netrc_locations:
 --- modulename: utils, funcname: <genexpr>
utils.py(211):          netrc_locations = (f"~/{f}" for f in NETRC_FILES)
utils.py(232):          if netrc_path is None:
utils.py(233):              return
sessions.py(483):          p = PreparedRequest()
 --- modulename: models, funcname: __init__
models.py(336):          self.method = None
models.py(338):          self.url = None
models.py(340):          self.headers = None
models.py(343):          self._cookies = None
models.py(345):          self.body = None
models.py(347):          self.hooks = default_hooks()
 --- modulename: hooks, funcname: default_hooks
hooks.py(16):      return {event: [] for event in HOOKS}
hooks.py(16):      return {event: [] for event in HOOKS}
models.py(349):          self._body_position = None
sessions.py(484):          p.prepare(
sessions.py(485):              method=request.method.upper(),
sessions.py(486):              url=request.url,
sessions.py(487):              files=request.files,
sessions.py(488):              data=request.data,
sessions.py(489):              json=request.json,
sessions.py(490):              headers=merge_setting(
sessions.py(491):                  request.headers, self.headers, dict_class=CaseInsensitiveDict
sessions.py(490):              headers=merge_setting(
 --- modulename: sessions, funcname: merge_setting
sessions.py(67):      if session_setting is None:
sessions.py(70):      if request_setting is None:
sessions.py(75):          isinstance(session_setting, Mapping) and isinstance(request_setting, Mapping)
 --- modulename: abc, funcname: __instancecheck__
<frozen abc>(119)
 --- modulename: abc, funcname: __instancecheck__
<frozen abc>(119)
sessions.py(79):      merged_setting = dict_class(to_key_val_list(session_setting))
 --- modulename: utils, funcname: to_key_val_list
utils.py(362):      if value is None:
utils.py(365):      if isinstance(value, (str, bytes, bool, int)):
utils.py(368):      if isinstance(value, Mapping):
 --- modulename: abc, funcname: __instancecheck__
<frozen abc>(119)
utils.py(369):          value = value.items()
 --- modulename: _collections_abc, funcname: items
<frozen _collections_abc>(829)
 --- modulename: _collections_abc, funcname: __init__
<frozen _collections_abc>(851)
utils.py(371):      return list(value)
 --- modulename: _collections_abc, funcname: __len__
<frozen _collections_abc>(854)
 --- modulename: structures, funcname: __len__
structures.py(61):          return len(self._store)
 --- modulename: _collections_abc, funcname: __iter__
<frozen _collections_abc>(898)
 --- modulename: structures, funcname: __iter__
structures.py(58):          return (casedkey for casedkey, mappedvalue in self._store.values())
 --- modulename: structures, funcname: <genexpr>
structures.py(58):          return (casedkey for casedkey, mappedvalue in self._store.values())
<frozen _collections_abc>(899)
 --- modulename: structures, funcname: __getitem__
structures.py(52):          return self._store[key.lower()][1]
 --- modulename: _collections_abc, funcname: __iter__
<frozen _collections_abc>(898)
 --- modulename: structures, funcname: <genexpr>
structures.py(58):          return (casedkey for casedkey, mappedvalue in self._store.values())
<frozen _collections_abc>(899)
 --- modulename: structures, funcname: __getitem__
structures.py(52):          return self._store[key.lower()][1]
 --- modulename: _collections_abc, funcname: __iter__
<frozen _collections_abc>(898)
 --- modulename: structures, funcname: <genexpr>
structures.py(58):          return (casedkey for casedkey, mappedvalue in self._store.values())
<frozen _collections_abc>(899)
 --- modulename: structures, funcname: __getitem__
structures.py(52):          return self._store[key.lower()][1]
 --- modulename: _collections_abc, funcname: __iter__
<frozen _collections_abc>(898)
 --- modulename: structures, funcname: <genexpr>
structures.py(58):          return (casedkey for casedkey, mappedvalue in self._store.values())
<frozen _collections_abc>(899)
 --- modulename: structures, funcname: __getitem__
structures.py(52):          return self._store[key.lower()][1]
 --- modulename: _collections_abc, funcname: __iter__
<frozen _collections_abc>(898)
 --- modulename: structures, funcname: <genexpr>
structures.py(58):          return (casedkey for casedkey, mappedvalue in self._store.values())
 --- modulename: structures, funcname: __init__
structures.py(41):          self._store = OrderedDict()
structures.py(42):          if data is None:
structures.py(44):          self.update(data, **kwargs)
 --- modulename: _collections_abc, funcname: update
<frozen _collections_abc>(985)
 --- modulename: abc, funcname: __instancecheck__
<frozen abc>(119)
<frozen _collections_abc>(988)
<frozen _collections_abc>(992)
<frozen _collections_abc>(993)
 --- modulename: structures, funcname: __setitem__
structures.py(49):          self._store[key.lower()] = (key, value)
<frozen _collections_abc>(992)
<frozen _collections_abc>(993)
 --- modulename: structures, funcname: __setitem__
structures.py(49):          self._store[key.lower()] = (key, value)
<frozen _collections_abc>(992)
<frozen _collections_abc>(993)
 --- modulename: structures, funcname: __setitem__
structures.py(49):          self._store[key.lower()] = (key, value)
<frozen _collections_abc>(992)
<frozen _collections_abc>(993)
 --- modulename: structures, funcname: __setitem__
structures.py(49):          self._store[key.lower()] = (key, value)
<frozen _collections_abc>(992)
<frozen _collections_abc>(994)
sessions.py(80):      merged_setting.update(to_key_val_list(request_setting))
 --- modulename: utils, funcname: to_key_val_list
utils.py(362):      if value is None:
utils.py(365):      if isinstance(value, (str, bytes, bool, int)):
utils.py(368):      if isinstance(value, Mapping):
 --- modulename: abc, funcname: __instancecheck__
<frozen abc>(119)
utils.py(369):          value = value.items()
utils.py(371):      return list(value)
 --- modulename: _collections_abc, funcname: update
<frozen _collections_abc>(985)
 --- modulename: abc, funcname: __instancecheck__
<frozen abc>(119)
<frozen _collections_abc>(988)
<frozen _collections_abc>(992)
<frozen _collections_abc>(994)
sessions.py(84):      none_keys = [k for (k, v) in merged_setting.items() if v is None]
 --- modulename: _collections_abc, funcname: items
<frozen _collections_abc>(829)
 --- modulename: _collections_abc, funcname: __init__
<frozen _collections_abc>(851)
 --- modulename: _collections_abc, funcname: __iter__
<frozen _collections_abc>(898)
 --- modulename: structures, funcname: __iter__
structures.py(58):          return (casedkey for casedkey, mappedvalue in self._store.values())
 --- modulename: structures, funcname: <genexpr>
structures.py(58):          return (casedkey for casedkey, mappedvalue in self._store.values())
<frozen _collections_abc>(899)
 --- modulename: structures, funcname: __getitem__
structures.py(52):          return self._store[key.lower()][1]
sessions.py(84):      none_keys = [k for (k, v) in merged_setting.items() if v is None]
 --- modulename: _collections_abc, funcname: __iter__
<frozen _collections_abc>(898)
 --- modulename: structures, funcname: <genexpr>
structures.py(58):          return (casedkey for casedkey, mappedvalue in self._store.values())
<frozen _collections_abc>(899)
 --- modulename: structures, funcname: __getitem__
structures.py(52):          return self._store[key.lower()][1]
sessions.py(84):      none_keys = [k for (k, v) in merged_setting.items() if v is None]
 --- modulename: _collections_abc, funcname: __iter__
<frozen _collections_abc>(898)
 --- modulename: structures, funcname: <genexpr>
structures.py(58):          return (casedkey for casedkey, mappedvalue in self._store.values())
<frozen _collections_abc>(899)
 --- modulename: structures, funcname: __getitem__
structures.py(52):          return self._store[key.lower()][1]
sessions.py(84):      none_keys = [k for (k, v) in merged_setting.items() if v is None]
 --- modulename: _collections_abc, funcname: __iter__
<frozen _collections_abc>(898)
 --- modulename: structures, funcname: <genexpr>
structures.py(58):          return (casedkey for casedkey, mappedvalue in self._store.values())
<frozen _collections_abc>(899)
 --- modulename: structures, funcname: __getitem__
structures.py(52):          return self._store[key.lower()][1]
sessions.py(84):      none_keys = [k for (k, v) in merged_setting.items() if v is None]
 --- modulename: _collections_abc, funcname: __iter__
<frozen _collections_abc>(898)
 --- modulename: structures, funcname: <genexpr>
structures.py(58):          return (casedkey for casedkey, mappedvalue in self._store.values())
sessions.py(85):      for key in none_keys:
sessions.py(88):      return merged_setting
sessions.py(493):              params=merge_setting(request.params, self.params),
 --- modulename: sessions, funcname: merge_setting
sessions.py(67):      if session_setting is None:
sessions.py(70):      if request_setting is None:
sessions.py(75):          isinstance(session_setting, Mapping) and isinstance(request_setting, Mapping)
 --- modulename: abc, funcname: __instancecheck__
<frozen abc>(119)
 --- modulename: abc, funcname: __instancecheck__
<frozen abc>(119)
sessions.py(79):      merged_setting = dict_class(to_key_val_list(session_setting))
 --- modulename: utils, funcname: to_key_val_list
utils.py(362):      if value is None:
utils.py(365):      if isinstance(value, (str, bytes, bool, int)):
utils.py(368):      if isinstance(value, Mapping):
 --- modulename: abc, funcname: __instancecheck__
<frozen abc>(119)
utils.py(369):          value = value.items()
utils.py(371):      return list(value)
sessions.py(80):      merged_setting.update(to_key_val_list(request_setting))
 --- modulename: utils, funcname: to_key_val_list
utils.py(362):      if value is None:
utils.py(365):      if isinstance(value, (str, bytes, bool, int)):
utils.py(368):      if isinstance(value, Mapping):
 --- modulename: abc, funcname: __instancecheck__
<frozen abc>(119)
utils.py(369):          value = value.items()
utils.py(371):      return list(value)
sessions.py(84):      none_keys = [k for (k, v) in merged_setting.items() if v is None]
sessions.py(85):      for key in none_keys:
sessions.py(88):      return merged_setting
sessions.py(494):              auth=merge_setting(auth, self.auth),
 --- modulename: sessions, funcname: merge_setting
sessions.py(67):      if session_setting is None:
sessions.py(68):          return request_setting
sessions.py(495):              cookies=merged_cookies,
sessions.py(496):              hooks=merge_hooks(request.hooks, self.hooks),
 --- modulename: sessions, funcname: merge_hooks
sessions.py(97):      if session_hooks is None or session_hooks.get("response") == []:
sessions.py(98):          return request_hooks
sessions.py(484):          p.prepare(
 --- modulename: models, funcname: prepare
models.py(366):          self.prepare_method(method)
 --- modulename: models, funcname: prepare_method
models.py(395):          self.method = method
models.py(396):          if self.method is not None:
models.py(397):              self.method = to_native_string(self.method.upper())
 --- modulename: _internal_utils, funcname: to_native_string
_internal_utils.py(30):      if isinstance(string, builtin_str):
_internal_utils.py(31):          out = string
_internal_utils.py(35):      return out
models.py(367):          self.prepare_url(url, params)
 --- modulename: models, funcname: prepare_url
models.py(416):          if isinstance(url, bytes):
models.py(419):              url = str(url)
models.py(422):          url = url.lstrip()
models.py(427):          if ":" in url and not url.lower().startswith("http"):
models.py(432):          try:
models.py(433):              scheme, auth, host, port, path, query, fragment = parse_url(url)
 --- modulename: url, funcname: parse_url
url.py(397):      if not url:
url.py(401):      source_url = url
url.py(402):      if not _SCHEME_RE.search(url):
url.py(403):          url = "//" + url
url.py(415):      try:
url.py(416):          scheme, authority, path, query, fragment = _URI_RE.match(url).groups()  # type: ignore[union-attr]
url.py(417):          normalize_uri = scheme is None or scheme.lower() in _NORMALIZABLE_SCHEMES
url.py(419):          if scheme:
url.py(422):          if authority:
url.py(423):              auth, _, host_port = authority.rpartition("@")
url.py(424):              auth = auth or None
url.py(425):              host, port = _HOST_PORT_RE.match(host_port).groups()  # type: ignore[union-attr]
url.py(426):              if auth and normalize_uri:
url.py(428):              if port == "":
url.py(433):          if port is not None:
url.py(438):              port_int = None
url.py(440):          host = _normalize_host(host, scheme)
 --- modulename: url, funcname: _normalize_host
url.py(304):      if host:
url.py(305):          if scheme in _NORMALIZABLE_SCHEMES:
url.py(306):              is_ipv6 = _IPV6_ADDRZ_RE.match(host)
url.py(307):              if is_ipv6:
url.py(324):              elif not _IPV4_RE.match(host):
url.py(325):                  return to_str(
url.py(326):                      b".".join([_idna_encode(label) for label in host.split(".")]),
 --- modulename: url, funcname: _idna_encode
url.py(333):      if not name.isascii():
url.py(348):      return name.lower().encode("ascii")
url.py(326):                      b".".join([_idna_encode(label) for label in host.split(".")]),
url.py(327):                      "ascii",
url.py(325):                  return to_str(
 --- modulename: util, funcname: to_str
util.py(22):      if isinstance(x, str):
util.py(24):      elif not isinstance(x, bytes):
util.py(26):      if encoding or errors:
util.py(27):          return x.decode(encoding or "utf-8", errors=errors or "strict")
url.py(442):          if normalize_uri and path:
url.py(445):          if normalize_uri and query:
url.py(447):          if normalize_uri and fragment:
url.py(457):      if not path:
url.py(458):          if query is not None or fragment is not None:
url.py(461):              path = None
url.py(463):      return Url(
url.py(464):          scheme=scheme,
url.py(465):          auth=auth,
url.py(466):          host=host,
url.py(467):          port=port_int,
url.py(468):          path=path,
url.py(469):          query=query,
url.py(470):          fragment=fragment,
url.py(463):      return Url(
 --- modulename: url, funcname: __new__
url.py(110):          if path and not path.startswith("/"):
url.py(112):          if scheme is not None:
url.py(114):          return super().__new__(cls, scheme, auth, host, port, path, query, fragment)
models.py(437):          if not scheme:
models.py(438):              raise MissingSchema(
models.py(439):                  f"Invalid URL {url!r}: No scheme supplied. "
models.py(440):                  f"Perhaps you meant https://{url}?"
models.py(439):                  f"Invalid URL {url!r}: No scheme supplied. "
models.py(438):              raise MissingSchema(
 --- modulename: exceptions, funcname: __init__
exceptions.py(19):          response = kwargs.pop("response", None)
exceptions.py(20):          self.response = response
exceptions.py(21):          self.request = kwargs.pop("request", None)
exceptions.py(22):          if response is not None and not self.request and hasattr(response, "request"):
exceptions.py(24):          super().__init__(*args, **kwargs)
my_utils.py(32):      except requests.exceptions.RequestException as e:
my_utils.py(34):          print(f"请求失败: {e}")
请求失败: Invalid URL 't': No scheme supplied. Perhaps you meant https://t?
my_utils.py(35):          return  # 遇到return直接退出函数
